#!/usr/bin/env python
#
# Script for bringing together the results generated by the analyze
# script (done in step 3).
#
# Mathieu Bernard

import argparse
import os

HEADER = "corpus speaker algo token_f-score token_precision token_recall \
boundary_f-score boundary_precision boundary_recall"


def list_subdirectories(directory, abspath=True, exclude=None):
    lsd = [os.path.abspath(os.path.join(directory, e))
           for e in os.listdir(directory) if e != '.DS_Store']
    lsd = [d for d in lsd if os.path.isdir(d)]
    if exclude is not None:
        lsd = [e for e in lsd if exclude not in e]
    if abspath is False:
        lsd = [os.path.basename(e) for e in lsd]
    return lsd


def read_cfgold(directory):
    cfgold = os.path.join(directory, 'cfgold-res.txt')
    if not os.path.isfile(cfgold):
        raise IOError('not found {}'.format(cfgold))

    lines = open(cfgold, 'r').readlines()
    if len(lines) < 2: # no results ?
        return ''
    return lines[-1].strip().replace('\t', ' ')


def collapse(res_dir, res_file, verbose=False):
    if verbose:
        print('collapsing results from {} to {}'.format(res_dir, res_file))

    collapsed = [HEADER + '\n']
    for corpus in sorted(list_subdirectories(res_dir)):
        for speaker in sorted(list_subdirectories(corpus)):
            if verbose:
                print 'Found ' + '/'.join(speaker.split('/')[-2:])
            for algo in sorted(
                    list_subdirectories(speaker, exclude='ngrams')):
                csa = algo.split('/')[-3:]
                try:
                    cfgold = read_cfgold(algo)
                    collapsed.append(' '.join(csa + [cfgold]) + '\n')
                except IOError as err:
                    if verbose:
                        print 'error with {}: {}'.format('/'.join(csa), err)

    open(res_file, 'w').writelines(collapsed)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-v', '--verbose', action='store_true')
    parser.add_argument(
        'results_directory', nargs='?',
        default=os.path.abspath(
            os.path.join(os.path.dirname(__file__), 'results')),
        help='default is %(default)s')
    parser.add_argument(
        '-o', '--output-file', default=None,
        help='default is result_directory/results.txt')

    args = parser.parse_args()
    res_dir = args.results_directory
    assert os.path.isdir(res_dir), 'error: {} not existing'.format(res_dir)

    res_file = args.output_file
    if res_file is None:
        res_file = os.path.join(res_dir, 'results.txt')

    collapse(res_dir, res_file, args.verbose)

if __name__ == '__main__':
    main()
